<div>
    <span><div><div><b>Assignments</b></div><div><b><br/></b></div><div>Stack and Heap</div><ul><li><div>Local Variables lives on the stack</div></li><li><div>Objects and instance variables in the heap</div></li></ul><div>Literals</div><ul><li><div><span> Integer literals can be decimal, octal or hexadecimal</span></div></li></ul><div>Scope</div><ul><li><div>Scope is the lifetime of a variable</div></li><li><div>four scopes</div></li><ul><li><div>Static - lives as long as their class lives</div></li><li><div>instance variables - as long as the object lives</div></li><li><div>local - as long as their method is in the stack, they are temporarily unavailable if stack calls another method</div></li><li><div>block - until block executes</div></li></ul></ul><div>Basic Assignments</div><ul><li><div>literal integers are implicitly ints</div></li><li><div>integer expression result always in int-sized result never smaller</div></li><li><div>floating points are doubles (64 bits)</div></li><li><div>narrowing a primitive truncates high order bits</div></li><li><div>compound assignment (+=) perform automatic casts</div></li><li><div>reference variables holds the bits that are used to refer to an object</div></li><li><div>when creating a new object : Button b = new Button();</div></li><ul><li><div>Make a reference variable b of Button</div></li><li><div>create new button</div></li><li><div>assign that button new object to the reference b</div></li></ul></ul><div>Using a Variable or Array</div><ul><li><div>when an array is instantiated, objects within the array are not automatically instantiated, but all the reference are created with default value of null</div></li><li><div>if array of primitive is created, elements get default value, ie, integers get 0</div></li><li><div>instance variables are always instantiated with default value</div></li><li><div>local/automatic/method variables do not come with default value</div></li></ul><div>Passing variables into methods</div><ul><li><div>methods can take primitives as well as object references</div></li><li><div>method arguments are always copies</div></li><li><div>method arguments are never actual object (they can be references to the objects)</div></li><li><div>primitive argument is an unattached copy of the original primitive</div></li><li><div>reference is another copy of the reference to the original object</div></li><li><div>Shadowing occurs with two variables with same name but different scope</div></li></ul><div>Array Declaration</div><ul><li><div>arrays are indexed with 0</div></li><li><div>multidimensional arrays are arrays of arrays</div></li><li><div>arrays can hold objects that passes an IS-A test</div></li><ul><li><div>ie an Animal Array can hold a Horse object, since Horse IS-A Animal</div></li></ul></ul><div>Initialization Blocks</div><ul><li><div>static blocks are run once, when the class is loaded</div></li><li><div>instance initialization blocks runs every time new instance is created</div></li></ul><div>Wrappers</div><ul><li><div>wrapper correlates with their primitive types</div></li><li><div>function is to wrap primitives as so they function like objects</div></li><li><div>provides primitives utility methods (usually conversion methods like parseXxx(), or xxxValue() or valueOf())</div></li></ul><div>Boxing</div><ul><li><div>allows you to convert primitive to wrappers automatically </div></li></ul><div>Garbage Collection</div><ul><li><div>GC provides automated memory management</div></li><li><div>delete objects that cannot be reached</div></li><li><div>no way to know algo for GC</div></li><li><div>objects must be eligible before they are garbage collected</div></li><ul><li><div>it is eligible if it no live thread can reach it</div></li></ul><li><div>GC prevents applications to run out of memory</div></li><li><div>Islands of objects can still be collected even if they refer to each other</div></li><li><div>Class has finalize() method where some things are performed before being GC, not generally used</div></li><li><div>finalize can actually make the object not eligible for GC if not used properly</div></li></ul><div><br/></div><div>Legal Operators</div><ul><li><div><span>Relational Operators  &gt; &gt;= &lt;  &lt;= == and != </span></div></li><li><div>instanceof - checks if an object is a subtype of another</div></li><li><div>arithmetic (+, -, *, /)</div></li><ul><li><div>Modulo (%) returns the remainder of a division</div></li></ul><li><div>String concatenation uses  +</div></li><ul><li><div>if both operands are numeric they add the value, else they use string concatenation</div></li></ul><li><div>Incrementors and decrementors: ++ and --</div></li><li><div>Ternary operators syntax:  (condition) ? dothisifTrue : doThisIfFalse</div></li><li><div>Logical Operators: &amp;&amp; || ^ !</div></li></ul><div><br/></div></div></span>
</div>