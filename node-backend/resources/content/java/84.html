<div>
    <span><div><br/></div><div><b>Declarations And Access Control</b></div><div>Identifiers</div><ul><li><div>Identifiers can begin with a letter, underscore or currency</div></li><li><div>after first character, it can be digits</div></li><li><div>can be any length</div></li><li><div>beans methods must be named using camelCase and depending on purpose must start with set,get, is, add or remove</div></li></ul><div>Declaration Rules</div><ul><li><div><span>Source code must have only one public class</span></div></li><li><div>File name must match public class name</div></li><li><div>file can have one package statement plus multiple imports</div></li><li><div>package must be first line</div></li><li><div>imports must follow the package line</div></li><li><div>file can have more than one non public class</div></li></ul><div>Access Modifiers</div><ul><li><div>4 access modifiers: public, protected private (and default which is without putting anything)</div></li><li><div>Classes can have public or default</div></li><li><div>class with default can only be seen in same package</div></li><li><div>class with public can be seen anywhere</div></li><li><div>class with visibility means they can:</div></li><ul><li><div>create instance of the class</div></li><li><div>extend or subclass another class</div></li><li><div>access methods and variables</div></li></ul></ul><div>Non-Access Modifiers</div><ul><li><div>classes can be modified to be final, abstract or strictfp</div></li><li><div>class cannot be both final and abstract - contradicting</div></li><li><div>final class cannot be subclassed</div></li><li><div>abstract classes cannot be instantiated</div></li><li><div>single abstract class method means the whole class must be abstract</div></li><li><div>abstract class can have both non abstract and abstract methods</div></li><li><div>first concrete class of abstract must implement all abstract methods</div></li></ul><div>Interface</div><ul><li><div>Interface are contracts of what a class can do</div></li><li><div>must be implemented, a class can implement multiple interfaces</div></li><li><div>interface is like a 100% abstract class</div></li><li><div>an interface can have only abstract methods, no concrete classes are alllowed</div></li><li><div>by default are public and abstract</div></li><li><div>can have constants but are implicitly public static final</div></li><li><div>legal non abstract class has the following properties:</div></li><ul><li><div>provides concrete implementation for the interface</div></li><li><div>follow all legal overrides</div></li><li><div>must not declare any new checked exception</div></li><li><div>checked exceptions must not be broader than originally declared</div></li><li><div>must maintain exact signature</div></li></ul><li><div>class implementing an interface can itself be abstract</div></li><li><div>abstract class does not need to implement all the methods but the first concrete class must</div></li><li><div>interfaces can extend other interfaces</div></li><li><div>interface cannot extend or implement a class or interface</div></li></ul><div>Member Access Modifiers</div><ul><li><div>Methods and instance variables are known as members</div></li><li><div>members can use all four access level: public protected default private</div></li><li><div>member access comes in tow forms </div></li><ul><li><div>code in one class can access a member of another class</div></li><li><div>or through inheritance</div></li></ul><li><div>if class cannot be accessed, then the members cannot be accessed</div></li><li><div>public can be accessed by all</div></li><li><div>if a superclass member is public, the subclass inherits its regardless of package</div></li><li><div>this - always refers to currently executing object</div></li><li><div>this.amethod() - is the same as executing aMethod in the same class</div></li><li><div>private members can be access only by code in the same class</div></li></ul><div>Local Variables</div><ul><li><div>local (method, automatic, or stack) variables cannot have access modifiers</div></li><li><div>final is the only modifier available to local variables</div></li><li><div>local variables don't get default values, must be initialized</div></li></ul><div>Other Modifiers</div><ul><li><div>final methods cannot be overriden</div></li><li><div>abstract methods are declared with a signature, return type, optional throw clause but are not implemented</div></li><li><div>abstract methods end in a semicolon without curly braces</div></li><li><div>synchronized modifier apples only to methods and code blocks</div></li><li><div>synchronized methods can have access control and can also be marked final</div></li><li><div>abstract methods must be implemented by a subclass </div></li></ul><div>Arrays</div><ul><li><div>Arrays can hold primitive or objects, but the array itself is always an object</div></li><li><div>declaring an array, brackets can be either left or right of variable name</div></li></ul><div>Static Variables and methods</div><ul><li><div>they are not tied to any particular instance of a class</div></li><li><div>no classes instances are needed in order to use static members</div></li><li><div>Only one copy</div></li><li><div>static methods do not have direct access to non-static methods</div></li></ul><div><b><br/></b></div><div><b>Object Orientation</b></div><div><br/></div><div>Encapsulation IS-A HAS-A</div><ul><li><div>Encapsulation hides an implementation behind an interface (or API)</div></li><li><div>Encapsulated means</div></li><ul><li><div>variables are kept protected usually via private modifier</div></li><li><div>getter and setter  are declared</div></li></ul><li><div>IS-A refers to inheritance or implementation</div></li><li><div>IS-A is represented by extends</div></li><li><div>HAS-A instance of another class</div></li></ul><div>Inheritance</div><ul><li><div>Allows another class to be a subclass of a superclass, inherits all public and protected variables and methods</div></li><li><div>Key concept in polymorphism, overriding, overloading and casting</div></li><li><div>All are subclass of Object class</div></li></ul><div>Polymorphism</div><ul><li><div>means &quot;many forms&quot;</div></li><li><div>reference variable is a always a single unchanging type but can be referred to a subtype object</div></li><li><div>single object can be referred to by a reference variable of many different types- as long as they are the same type or supertype of the object</div></li><li><div>the reference variable determine which methods can be called</div></li></ul><div>Overriding and Overloading</div><ul><li><div>methods can be overridden or overloaded; constructors can only be overloaded</div></li><li><div>Overriding:</div></li><ul><li><div>must have same argument list</div></li><li><div>must have same same return type</div></li><li><div>must have not more restrictive access modifier</div></li><li><div>must not throw broader exception</div></li></ul><li><div>final methods cannot be overridden</div></li><li><div>private methods are not inherited hence cannot be overridden/overloaded</div></li><li><div>Polymorphism applies to overriding not overloading!</div></li><li><div>Object type determines which overridden method is used at runtime</div></li></ul><div>Reference Variable Casting</div><ul><li><div>Downcasting - use for a subtype of an object , you can assign the reference variable to the subtype, an explicit cast is needed for this</div></li><li><div>Upcasting - can be done implicitly use for casting reference variable to supertype</div></li></ul><div>Interface</div><ul><li><div>single class can have multiple interfaces,</div></li><li><div>need to fulfill all the interfaces contracts</div></li></ul><div>Return type</div><ul><li><div>overloaded methods can change return type</div></li><li><div>void means no return type - so you can simply call return in the method to end the method early</div></li><li><div>methods with an object reference type can return a subtype</div></li></ul><div>Constructor</div><ul><li><div>constructor is always invoked when new is created</div></li><li><div>each superclass in object's inheritance tree will have a constructor called</div></li><li><div>each class has at least one constructor</div></li></ul><ul><li><div>constructor must have the same name as the class</div></li><li><div>constructors doesn't have return type</div></li><li><div>default constructor is a no arg constructor with no-arg call to super</div></li><li><div>can never be inherited</div></li><li><div>there is always default no-arg constructor, if you create one constructor, that no-arg constructor is gone and you need to create one for yourself</div></li><li><div>first call must always be super() - compiler adds this for you</div></li></ul><div>Coupling and Cohesion</div><ul><li><div>Coupling refers to the degree which class knows about another class</div></li><li><div>Loose coupling is the desired state</div></li><li><div>Cohesion refers degree of a class which has single well defined role or responsibility</div></li><li><div>High Cohesion is the desired state</div></li></ul><div><br/></div><div><br/></div></span>
</div>